#!/bin/bash

# SPDX-FileCopyrightText: 2023 - 2023 ENCRYPTED SUPPORT LP <adrelanos@kicksecure.com>
#
# SPDX-License-Identifier: AGPL-3.0-or-later

# Usage: image-to-iso <raw_image_file> <iso_tmp_dir> <iso_image_file>

# This script generates a bootable ISO image.
# It takes a bootable raw disk image as input and outputs a bootable ISO image.
# The script is designed to support both booting methods:
# - EFI (Unified Extensible Firmware Interface) and,
# - legacy BIOS booting.
#
# Limitations:
# - Only tested with images creates by grml-debootstrap --vmfile --vmefi,
#   see corresponding createimg1 script.
# - Makes some assumptions about the partition layout.

# Enable debugging, exit on error, and fail on pipe errors.
set -x
set -e
set -o pipefail

error_handler() {
  if test -n "${BASH_COMMAND:-}"; then
    # shellcheck disable=SC2039,3028,3054
    true "ERROR: Executed script, function, command executed: '${0}' '${FUNCNAME[1]}' '${BASH_COMMAND}'"
  else
    true "ERROR: Executed script: '${0}'"
  fi
  unmount_cleanup || true "ERROR: Cleanup unmounting failed." >&2
}

parse_arguments() {
  if [ $# -lt 3 ]; then
    echo "Usage: $0 <raw_image_file> <iso_tmp_dir> <iso_image_file>" >&2
    exit 1
  fi

  RAW_IMAGE_FILE="$1"
  ISO_TMP_DIR="$2"
  ISO_IMAGE_FILE="$3"
}

check_root() {
  if [ ! "$(id -u)" = "0" ]; then
    true "ERROR: Must be run with root privileges (sudo)! sudo $0" >&2
    exit 1
  fi
}

check_dependencies() {
  true "Ensure necessary commands are available..."

  test -x ./grub-raw-cfg-to-grub-iso-cfg
  command -v mksquashfs >/dev/null
  command -v grub-mkrescue >/dev/null
  command -v xorriso >/dev/null
  command -v kpartx >/dev/null
  command -v mount >/dev/null
  command -v umount >/dev/null
  command -v rmdir >/dev/null

  # Undocumented dependencies by grub-mkrescue.
  dpkg -l | grep grub-efi-amd64-bin >/dev/null
  dpkg -l | grep grub-efi-amd64-signed >/dev/null
  dpkg -l | grep mtools >/dev/null
}

setup_image_mount() {
  true "Mount the image file and set up loopback device..."
  DEVINFO=$(kpartx -a -s -v "${RAW_IMAGE_FILE}")
  # example DEVINFO:
  # add map loop1p1 (253:3): 0 204800 linear 7:1 2048
  # add map loop1p2 (253:4): 0 2048 linear 7:1 206848
  # add map loop1p3 (253:5): 0 209504256 linear 7:1 208896

  if [ -z "${DEVINFO}" ] ; then
    echo "Error setting up loopback device." >&2
    exit 1
  fi
}

prepare_loopback_info() {
  true "Extract and prepare loopback device information..."
  LOOP_PART="${DEVINFO##add map }"
  LOOP_PART="${LOOP_PART// */}"
  EFI_TARGET="/dev/mapper/$LOOP_PART"
  # example: EFI_TARGET
  # /dev/mapper/loop1p1

  LOOP_PART="${LOOP_PART%p1}p3"
  ROOTFS_TARGET="/dev/mapper/${LOOP_PART}"
  # example ROOTFS_TARGET:
  # /dev/mapper/loop1p3

  MNTPOINT=$(mktemp -d)
}

mount_file_systems() {
  true "Mount the target file system and EFI partition..."
  mount "${ROOTFS_TARGET}" "${MNTPOINT}"
  mount "${EFI_TARGET}" "${MNTPOINT}/boot/efi"
}

create_iso_directories() {
  # Clear and create necessary directories in the temporary ISO directory.
  rm -r -f "${ISO_TMP_DIR}"
  mkdir --parents "${ISO_TMP_DIR}/LiveOS"

  ## Old implementation only creating grub.cfg.
  #mkdir --parents "${ISO_TMP_DIR}/boot/grub"
}

get_file_names() {
  true "Retrieve the kernel version from the mounted image..."
  KVERSION=$(cd "${MNTPOINT}/boot" && find vmlinuz-* | tail -1 | sed 's@vmlinuz-@@')

  # Define paths for the kernel file and initial ramdisk.
  kernel_file_name="vmlinuz-${KVERSION}"
  initial_ramdisk_file_name="initrd.img-${KVERSION}"
}

create_squashfs() {
  true "Creating squashfs..."
  ## Take the contents of the VM image and create the squashfs.img file in the LiveOS folder
  ## within the temporary ISO directory.
  ##
  ## The /LiveOS/squashfs.img path is a default setting used by dracut.
  ##
  ## During development, especially when testing various kernel boot parameters, it may be
  ## unnecessary to repeatedly recreate the squashfs file.
  ##
  ## TODO: Consider porting to squashfs-tools-ng for potential improvements in speed and size reduction.
  mksquashfs "${MNTPOINT}" "${ISO_TMP_DIR}/LiveOS/squashfs.img" -noappend
}

copy_kernel_and_initial_ramdisk_and_grub_config() {
  true "Copy kernel and initial ramdisk to the temporary ISO directory..."

  ## Was functional.
  ## But lacks the real grub folder which contains grub modules.
  ## Hence replaced with the full grub folder.
  #cp -a "${MNTPOINT}/boot/${kernel_file_name}" "${ISO_TMP_DIR}/boot/${kernel_file_name}"
  #cp -a "${MNTPOINT}/boot/${initial_ramdisk_file_name}" "${ISO_TMP_DIR}/boot/${initial_ramdisk_file_name}"

  cp -a -r "${MNTPOINT}/boot" "${ISO_TMP_DIR}/boot"

  ## Create a copy of the grub.cfg from the raw image as a template for later
  ## adjustment to be functional for the ISO.
  cp -a "${MNTPOINT}/boot/grub/grub.cfg" "${ISO_TMP_DIR}/boot/grub/grub-raw-image-temp.cfg"
}

unmount_cleanup() {
  true "Unmount partitions and clean up loopback device..."

  ## syntax:
  #~/derivative-maker/help-steps/unmount-helper -- /tmp/user/0/tmp.6UT5XIy8K9

  # XXX: hardcoded path
  if test -x ~/derivative-maker/help-steps/unmount-helper ; then
    umount_tool=~/derivative-maker/help-steps/unmount-helper
  else
    umount_tool=umount
  fi

  if test -n "${MNTPOINT}"; then
    $umount_tool "${MNTPOINT}/boot/efi"
    $umount_tool "${MNTPOINT}"
  fi
  if test -n "${ROOTFS_TARGET}"; then
    kpartx -d "${ROOTFS_TARGET}"
  fi
  if test -n "${MNTPOINT}"; then
    $umount_tool "${MNTPOINT}"
  fi
}

grub_raw_image_config_to_grub_iso_image_config() {
  true "Create the GRUB configuration file for the ISO."

  # Notes:
  # - The /boot folder originates from the temporary ISO directory.
  #   It will only be available during very early boot.
  # - Once dracut set up the root system, there might be a different /boot,
  #   which originates from the raw image.
  # - This means kernel and initial ramdisk are duplicated. In theory,
  #   it might be possible to omit adding the /boot folder from squashfs.img.
  # - This might be confusing, but makes it easier to generate a
  #   /boot/grub/grub.cfg file based on the VM image.

  ## Was functional.
  ## Replaced with a more complex implementation below for the ISO to inherit
  ## same grub.cfg from the raw image but adjusted to work with the ISO.
  # cat << EOF > "${ISO_TMP_DIR}/boot/grub/grub.cfg"
  # set default="0"
  # set timeout=10
  # menuentry "Linux" {
  #     linux /boot/${kernel_file_name} root=live:CDLABEL=test rd.live.image rd.debug rd.live.debug rd.live.overlay.overlayfs=1 console=ttyS0
  #     initrd /boot/${initial_ramdisk_file_name}
  # }
  # EOF

  iso_grub_extra_params=""
  iso_grub_extra_params+=" root=live:CDLABEL=test"
  iso_grub_extra_params+=" rd.live.image"
  iso_grub_extra_params+=" rd.live.overlay.overlayfs=1"
  iso_grub_extra_params+=" rd.debug"
  iso_grub_extra_params+=" rd.live.debug"
  iso_grub_extra_params+=" console=ttyS0"

  # Convert grub.cfg from raw image to grub.cfg usable for ISO image.
  #
  # Keep original grub-raw-image-temp.cfg for later comparison purposes.
  ./grub-raw-cfg-to-grub-iso-cfg "${ISO_TMP_DIR}/boot/grub/grub-raw-image-temp.cfg" "${ISO_TMP_DIR}/boot/grub/grub.cfg" "${iso_grub_extra_params}"
}

create_iso() {
  true "Create the ISO using grub-mkrescue based on the temporary ISO directory..."

  # '-V test' set label to 'test'. This must match the 'root=live:CDLABEL=test' kernel command line.
  true "Creating ISO..."
  grub-mkrescue --verbose -V test -o "${ISO_IMAGE_FILE}" "${ISO_TMP_DIR}"
}

cleanup_temporary_files() {
  true "Cleanup temporary files..."
  # Not deleting for easier debugging.
  #rm -r "${ISO_TMP_DIR}"
}

main() {
  parse_arguments "$@"
  check_root
  check_dependencies
  setup_image_mount
  prepare_loopback_info
  mount_file_systems
  create_iso_directories
  get_file_names
  create_squashfs
  copy_kernel_and_initial_ramdisk_and_grub_config
  unmount_cleanup
  grub_raw_image_config_to_grub_iso_image_config
  create_iso
  cleanup_temporary_files
  true "Done."
}

# shellcheck disable=SC2039,3047
trap 'error_handler $? ${LINENO:-}' ERR

main "$@"
